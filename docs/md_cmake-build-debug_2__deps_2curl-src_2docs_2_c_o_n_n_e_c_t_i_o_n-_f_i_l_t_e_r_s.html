<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CrossGuard: curl connection filters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CrossGuard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">curl connection filters</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md890"></a> Connection filters is a design in the internals of curl, not visible in its public API. They were added in curl v7.xx.x. This document describes the concepts, its high level implementation and the motivations.</p>
<h1><a class="anchor" id="autotoc_md891"></a>
Filters</h1>
<p>A "connection filter" is a piece of code that is responsible for handling a range of operations of curl's connections: reading, writing, waiting on external events, connecting and closing down - to name the most important ones.</p>
<p>The most important feat of connection filters is that they can be stacked on top of each other (or "chained" if you prefer that metaphor). In the common scenario that you want to retrieve a <code>https:</code> url with curl, you need 2 basic things to send the request and get the response: a TCP connection, represented by a <code>socket</code> and a SSL instance en- and decrypt over that socket. You write your request to the SSL instance, which encrypts and writes that data to the socket, which then sends the bytes over the network.</p>
<p>With connection filters, curl's internal setup will look something like this (cf for connection filter):</p>
<div class="fragment"><div class="line">Curl_easy *data         connectdata *conn        cf-ssl        cf-socket</div>
<div class="line">+----------------+      +-----------------+      +-------+     +--------+</div>
<div class="line">|https://curl.se/|----&gt; | properties      |----&gt; | keys  |---&gt; | socket |--&gt; OS --&gt; network</div>
<div class="line">+----------------+      +-----------------+      +-------+     +--------+</div>
<div class="line"> </div>
<div class="line"> Curl_write(data, buffer)</div>
<div class="line">  --&gt; Curl_cfilter_write(data, data-&gt;conn, buffer)</div>
<div class="line">       ---&gt; conn-&gt;filter-&gt;write(conn-&gt;filter, data, buffer)</div>
</div><!-- fragment --><p>While connection filters all do different things, they look the same from the "outside". The code in <code>data</code> and <code>conn</code> does not really know <b>which</b> filters are installed. <code>conn</code> just writes into the first filter, whatever that is.</p>
<p>Same is true for filters. Each filter has a pointer to the <code>next</code> filter. When SSL has encrypted the data, it does not write to a socket, it writes to the next filter. If that is indeed a socket, or a file, or an HTTP/2 connection is of no concern to the SSL filter.</p>
<p>And this allows the stacking, as in:</p>
<div class="fragment"><div class="line">Direct:</div>
<div class="line">  http://localhost/      conn -&gt; cf-socket</div>
<div class="line">  https://curl.se/       conn -&gt; cf-ssl -&gt; cf-socket</div>
<div class="line">Via http proxy tunnel:</div>
<div class="line">  http://localhost/      conn -&gt; cf-http-proxy -&gt; cf-socket</div>
<div class="line">  https://curl.se/       conn -&gt; cf-ssl -&gt; cf-http-proxy -&gt; cf-socket</div>
<div class="line">Via https proxy tunnel:</div>
<div class="line">  http://localhost/      conn -&gt; cf-http-proxy -&gt; cf-ssl -&gt; cf-socket</div>
<div class="line">  https://curl.se/       conn -&gt; cf-ssl -&gt; cf-http-proxy -&gt; cf-ssl -&gt; cf-socket</div>
<div class="line">Via http proxy tunnel via SOCKS proxy:</div>
<div class="line">  http://localhost/      conn -&gt; cf-http-proxy -&gt; cf-socks -&gt; cf-socket</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md892"></a>
Connecting/Closing</h2>
<p>Before <code><a class="el" href="struct_curl__easy.html">Curl_easy</a></code> can send the request, the connection needs to be established. This means that all connection filters have done, whatever they need to do: waiting for the socket to be connected, doing the TLS handshake, performing the <a class="el" href="struct_h_t_t_p.html">HTTP</a> tunnel request, etc. This has to be done in reverse order: the last filter has to do its connect first, then the one above can start, etc.</p>
<p>Each filter does in principle the following:</p>
<div class="fragment"><div class="line">static CURLcode</div>
<div class="line">myfilter_cf_connect(struct Curl_cfilter *cf,</div>
<div class="line">                    struct Curl_easy *data,</div>
<div class="line">                    bool *done)</div>
<div class="line">{</div>
<div class="line">  CURLcode result;</div>
<div class="line"> </div>
<div class="line">  if(cf-&gt;connected) {            /* we and all below are done */</div>
<div class="line">    *done = TRUE;</div>
<div class="line">    return CURLE_OK;</div>
<div class="line">  }</div>
<div class="line">                                 /* Let the filters below connect */</div>
<div class="line">  result = cf-&gt;next-&gt;cft-&gt;connect(cf-&gt;next, data, blocking, done);</div>
<div class="line">  if(result || !*done)</div>
<div class="line">    return result;               /* below errored/not finished yet */</div>
<div class="line"> </div>
<div class="line">  /* MYFILTER CONNECT THINGS */  /* below connected, do out thing */</div>
<div class="line">  *done = cf-&gt;connected = TRUE;  /* done, remember, return */</div>
<div class="line">  return CURLE_OK;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Closing a connection then works similar. The <code>conn</code> tells the first filter to close. Contrary to connecting, the filter does its own things first, before telling the next filter to close.</p>
<h2><a class="anchor" id="autotoc_md893"></a>
Efficiency</h2>
<p>There are two things curl is concerned about: efficient memory use and fast transfers.</p>
<p>The memory footprint of a filter is relatively small:</p>
<div class="fragment"><div class="line">struct Curl_cfilter {</div>
<div class="line">  const struct Curl_cftype *cft; /* the type providing implementation */</div>
<div class="line">  struct Curl_cfilter *next;     /* next filter in chain */</div>
<div class="line">  void *ctx;                     /* filter type specific settings */</div>
<div class="line">  struct connectdata *conn;      /* the connection this filter belongs to */</div>
<div class="line">  int sockindex;                 /* TODO: like to get rid off this */</div>
<div class="line">  BIT(connected);                /* != 0 iff this filter is connected */</div>
<div class="line">};</div>
</div><!-- fragment --><p> The filter type <code>cft</code> is a singleton, one static struct for each type of filter. The <code>ctx</code> is where a filter will hold its specific data. That varies by filter type. An http-proxy filter will keep the ongoing state of the CONNECT here, but free it after its has been established. The SSL filter will keep the <code>SSL*</code> (if OpenSSL is used) here until the connection is closed. So, this varies.</p>
<p><code>conn</code> is a reference to the connection this filter belongs to, so nothing extra besides the pointer itself.</p>
<p>Several things, that before were kept in <code>struct connectdata</code>, will now go into the <code>filter-&gt;ctx</code> <em>when needed</em>. So, the memory footprint for connections that do <em>not</em> use an http proxy, or socks, or https will be lower.</p>
<p>As to transfer efficiency, writing and reading through a filter comes at near zero cost <em>if the filter does not transform the data</em>. An http proxy or socks filter, once it is connected, will just pass the calls through. Those filters implementations will look like this:</p>
<div class="fragment"><div class="line">ssize_t  Curl_cf_def_send(struct Curl_cfilter *cf, struct Curl_easy *data,</div>
<div class="line">                          const void *buf, size_t len, CURLcode *err)</div>
<div class="line">{</div>
<div class="line">  return cf-&gt;next-&gt;cft-&gt;do_send(cf-&gt;next, data, buf, len, err);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The <code>recv</code> implementation is equivalent.</p>
<h1><a class="anchor" id="autotoc_md894"></a>
Filter Types</h1>
<p>The (currently) existing filter types are: SOCKET, SOCKET-ACCEPT, SSL, HTTP-PROXY and SOCKS-PROXY. Vital to establishing and read/writing a connection. But filters are also a good way to implement tasks for <em>managing</em> a connection:</p>
<ul>
<li><b>Statistics</b>: a filter that counts the number of bytes sent/received. Place one in front of SOCKET and one higher up and get the number of raw and "easy" bytes transferred. They may track the speed as well, or number of partial writes, etc.</li>
<li><b>Timeout</b>: enforce timeouts, e.g. fail if a connection cannot be established in a certain amount of time.</li>
<li><b><a class="el" href="struct_progress.html">Progress</a></b>: report progress on a connection.</li>
<li><b>Pacing</b>: limit read/write rates.</li>
<li><b>Testing</b>: simulate network condition or failures.</li>
</ul>
<p>As you see, filters are a good way to add functionality to curl's internal handling of transfers without impact on other code.</p>
<h1><a class="anchor" id="autotoc_md895"></a>
Easy Filters?</h1>
<p>Some things that curl needs to manage are not directly tied to a specific connection but the property of the <code><a class="el" href="struct_curl__easy.html">Curl_easy</a></code> handle, e.g. a particular transfer. When using HTTP/2 or HTTP/3, many transfers can use the same connection. If one wants to monitor of the transfer itself or restricting its speed alone, a connection filter is not the right place to do this.</p>
<p>So we might add "easy filters" one day. Who knows? </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
