<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CrossGuard: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CrossGuard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Introduction</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md703"></a> This directory contains SystemZ deflate hardware acceleration support. It can be enabled using the following build commands: </p><pre class="fragment">$ ./configure --with-dfltcc-deflate --with-dfltcc-inflate
$ make
</pre><p> or </p><pre class="fragment">$ cmake -DWITH_DFLTCC_DEFLATE=1 -DWITH_DFLTCC_INFLATE=1 .
$ make
</pre><p> When built like this, zlib-ng would compress using hardware on level 1, and using software on all other levels. Decompression will always happen in hardware. In order to enable hardware compression for levels 1-6 (i.e. to make it used by default) one could add <code>-DDFLTCC_LEVEL_MASK=0x7e</code> to CFLAGS when building zlib-ng.</p>
<p>SystemZ deflate hardware acceleration is available on <a href="https://www.ibm.com/products/z15">IBM z15</a> and newer machines under the name <a href="https://www.ibm.com/support/z-content-solutions/compression/">"Integrated Accelerator for zEnterprise Data Compression"</a>. The programming interface to it is a machine instruction called DEFLATE CONVERSION CALL (DFLTCC). It is documented in Chapter 26 of <a href="https://publibfp.dhe.ibm.com/epubs/pdf/a227832c.pdf">Principles of Operation</a>. Both the code and the rest of this document refer to this feature simply as "DFLTCC".</p>
<h1><a class="anchor" id="autotoc_md704"></a>
Performance</h1>
<p>Performance figures are published [here]( <a href="https://github.com/iii-i/zlib-ng/wiki/Performance-with-dfltcc-patch-applied-and-dfltcc-support-built-on-dfltcc-enabled-machine">https://github.com/iii-i/zlib-ng/wiki/Performance-with-dfltcc-patch-applied-and-dfltcc-support-built-on-dfltcc-enabled-machine</a> ). The compression speed-up can be as high as 110x and the decompression speed-up can be as high as 15x.</p>
<h1><a class="anchor" id="autotoc_md705"></a>
Limitations</h1>
<p>Two DFLTCC compression calls with identical inputs are not guaranteed to produce identical outputs. Therefore care should be taken when using hardware compression when reproducible results are desired. In particular, zlib-ng-specific <code>zng_deflateSetParams</code> call allows setting <code>Z_DEFLATE_REPRODUCIBLE</code> parameter, which disables DFLTCC support for a particular stream.</p>
<p>DFLTCC does not support every single zlib-ng feature, in particular:</p>
<ul>
<li><code>inflate(Z_BLOCK)</code> and <code>inflate(Z_TREES)</code></li>
<li><code>inflateMark()</code></li>
<li><code>inflatePrime()</code></li>
<li><code>inflateSyncPoint()</code></li>
</ul>
<p>When used, these functions will either switch to software, or, in case this is not possible, gracefully fail.</p>
<h1><a class="anchor" id="autotoc_md706"></a>
Code structure</h1>
<p>All SystemZ-specific code lives in <code>arch/s390</code> directory and is integrated with the rest of zlib-ng using hook macros.</p>
<h2><a class="anchor" id="autotoc_md707"></a>
Hook macros</h2>
<p>DFLTCC takes as arguments a parameter block, an input buffer, an output buffer and a window. <code>ZALLOC_DEFLATE_STATE()</code>, <code>ZALLOC_INFLATE_STATE()</code>, <code>ZFREE_STATE()</code>, <code>ZCOPY_DEFLATE_STATE()</code>, <code>ZCOPY_INFLATE_STATE()</code>, <code>ZALLOC_WINDOW()</code>, <code>ZCOPY_WINDOW()</code> and <code>TRY_FREE_WINDOW()</code> macros encapsulate allocation details for the parameter block (which is allocated alongside zlib-ng state) and the window (which must be page-aligned and large enough).</p>
<p>Software and hardware window formats do not match, therefore, <code>deflateSetDictionary()</code>, <code>deflateGetDictionary()</code>, <code>inflateSetDictionary()</code> and <code>inflateGetDictionary()</code> need special handling, which is triggered using <code>DEFLATE_SET_DICTIONARY_HOOK()</code>, <code>DEFLATE_GET_DICTIONARY_HOOK()</code>, <code>INFLATE_SET_DICTIONARY_HOOK()</code> and <code>INFLATE_GET_DICTIONARY_HOOK()</code> macros.</p>
<p><code>deflateResetKeep()</code> and <code>inflateResetKeep()</code> update the DFLTCC parameter block using <code>DEFLATE_RESET_KEEP_HOOK()</code> and <code>INFLATE_RESET_KEEP_HOOK()</code> macros.</p>
<p><code>INFLATE_PRIME_HOOK()</code>, <code>INFLATE_MARK_HOOK()</code> and <code>INFLATE_SYNC_POINT_HOOK()</code> macros make the respective unsupported calls gracefully fail.</p>
<p><code>DEFLATE_PARAMS_HOOK()</code> implements switching between hardware and software compression mid-stream using <code>deflateParams()</code>. Switching normally entails flushing the current block, which might not be possible in low memory situations. <code>deflateParams()</code> uses <code>DEFLATE_DONE()</code> hook in order to detect and gracefully handle such situations.</p>
<p>The algorithm implemented in hardware has different compression ratio than the one implemented in software. <code>DEFLATE_BOUND_ADJUST_COMPLEN()</code> and <code>DEFLATE_NEED_CONSERVATIVE_BOUND()</code> macros make <code>deflateBound()</code> return the correct results for the hardware implementation.</p>
<p>Actual compression and decompression are handled by <code>DEFLATE_HOOK()</code> and <code>INFLATE_TYPEDO_HOOK()</code> macros. Since inflation with DFLTCC manages the window on its own, calling <code>updatewindow()</code> is suppressed using <code>INFLATE_NEED_UPDATEWINDOW()</code> macro.</p>
<p>In addition to compression, DFLTCC computes CRC-32 and Adler-32 checksums, therefore, whenever it's used, software checksumming is suppressed using <code>DEFLATE_NEED_CHECKSUM()</code> and <code>INFLATE_NEED_CHECKSUM()</code> macros.</p>
<p>While software always produces reproducible compression results, this is not the case for DFLTCC. Therefore, zlib-ng users are given the ability to specify whether or not reproducible compression results are required. While it is always possible to specify this setting before the compression begins, it is not always possible to do so in the middle of a deflate stream - the exact conditions for that are determined by <code>DEFLATE_CAN_SET_REPRODUCIBLE()</code> macro.</p>
<h2><a class="anchor" id="autotoc_md708"></a>
SystemZ-specific code</h2>
<p>When zlib-ng is built with DFLTCC, the hooks described above are converted to calls to functions, which are implemented in <code>arch/s390/dfltcc_*</code> files. The functions can be grouped in three broad categories:</p>
<ul>
<li>Base DFLTCC support, e.g. wrapping the machine instruction - <code>dfltcc()</code> and allocating aligned memory - <code>dfltcc_alloc_state()</code>.</li>
<li>Translating between software and hardware data formats, e.g. <code>dfltcc_deflate_set_dictionary()</code>.</li>
<li>Translating between software and hardware state machines, e.g. <code>dfltcc_deflate()</code> and <code>dfltcc_inflate()</code>.</li>
</ul>
<p>The functions from the first two categories are fairly simple, however, various quirks in both software and hardware state machines make the functions from the third category quite complicated.</p>
<h3><a class="anchor" id="autotoc_md709"></a>
<code>dfltcc_deflate()</code> function</h3>
<p>This function is called by <code>deflate()</code> and has the following responsibilities:</p>
<ul>
<li>Checking whether DFLTCC can be used with the current stream. If this is not the case, then it returns <code>0</code>, making <code>deflate()</code> use some other function in order to compress in software. Otherwise it returns <code>1</code>.</li>
<li>Block management and Huffman table generation. DFLTCC ends blocks only when explicitly instructed to do so by the software. Furthermore, whether to use fixed or dynamic Huffman tables must also be determined by the software. Since looking at data in order to gather statistics would negate performance benefits, the following approach is used: the first <code>DFLTCC_FIRST_FHT_BLOCK_SIZE</code> bytes are placed into a fixed block, and every next <code>DFLTCC_BLOCK_SIZE</code> bytes are placed into dynamic blocks.</li>
<li>Writing EOBS. Block Closing Control bit in the parameter block instructs DFLTCC to write EOBS, however, certain conditions need to be met: input data length must be non-zero or Continuation Flag must be set. To put this in simpler terms, DFLTCC will silently refuse to write EOBS if this is the only thing that it is asked to do. Since the code has to be able to emit EOBS in software anyway, in order to avoid tricky corner cases Block Closing Control is never used. Whether to write EOBS is instead controlled by <code>soft_bcc</code> variable.</li>
<li>Triggering block post-processing. Depending on flush mode, <code>deflate()</code> must perform various additional actions when a block or a stream ends. <code>dfltcc_deflate()</code> informs <code>deflate()</code> about this using <code>block_state *result</code> parameter.</li>
<li>Converting software state fields into hardware parameter block fields, and vice versa. For example, <code>wrap</code> and Check Value Type or <code>bi_valid</code> and Sub-Byte Boundary. Certain fields cannot be translated and must persist untouched in the parameter block between calls, for example, Continuation Flag or Continuation <a class="el" href="struct_state.html">State</a> Buffer.</li>
<li>Handling flush modes and low-memory situations. These aspects are quite intertwined and pervasive. The general idea here is that the code must not do anything in software - whether explicitly by e.g. calling <code>send_eobs()</code>, or implicitly - by returning to <code>deflate()</code> with certain return and <code>*result</code> values, when Continuation Flag is set.</li>
<li>Ending streams. When a new block is started and flush mode is <code>Z_FINISH</code>, Block Header Final parameter block bit is used to mark this block as final. However, sometimes an empty final block is needed, and, unfortunately, just like with EOBS, DFLTCC will silently refuse to do this. The general idea of DFLTCC implementation is to rely as much as possible on the existing code. Here in order to do this, the code pretends that it does not support DFLTCC, which makes <code>deflate()</code> call a software compression function, which writes an empty final block. Whether this is required is controlled by <code>need_empty_block</code> variable.</li>
<li>Error handling. This is simply converting Operation-Ending-Supplemental Code to string. Errors can only happen due to things like memory corruption, and therefore they don't affect the <code>deflate()</code> return code.</li>
</ul>
<h3><a class="anchor" id="autotoc_md710"></a>
<code>dfltcc_inflate()</code> function</h3>
<p>This function is called by <code>inflate()</code> from the <code>TYPEDO</code> state (that is, when all the metadata is parsed and the stream is positioned at the type bits of deflate block header) and it's responsible for the following:</p>
<ul>
<li>Falling back to software when flush mode is <code>Z_BLOCK</code> or <code>Z_TREES</code>. Unfortunately, there is no way to ask DFLTCC to stop decompressing on block or tree boundary.</li>
<li><code>inflate()</code> decompression loop management. This is controlled using the return value, which can be either <code>DFLTCC_INFLATE_BREAK</code> or <code>DFLTCC_INFLATE_CONTINUE</code>.</li>
<li>Converting software state fields into hardware parameter block fields, and vice versa. For example, <code>whave</code> and History Length or <code>wnext</code> and History Offset.</li>
<li>Ending streams. This instructs <code>inflate()</code> to return <code>Z_STREAM_END</code> and is controlled by <code>last</code> state field.</li>
<li>Error handling. Like deflate, error handling comprises Operation-Ending-Supplemental Code to string conversion. Unlike deflate, errors may happen due to bad inputs, therefore they are propagated to <code>inflate()</code> by setting <code>mode</code> field to <code>MEM</code> or <code>BAD</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md711"></a>
Testing</h1>
<p>Given complexity of DFLTCC machine instruction, it is not clear whether QEMU TCG will ever support it. At the time of writing, one has to have access to an IBM z15+ VM or LPAR in order to test DFLTCC support. Since DFLTCC is a non-privileged instruction, neither special VM/LPAR configuration nor root are required.</p>
<p>zlib-ng CI uses an IBM-provided z15 self-hosted builder for the DFLTCC testing. There are no IBM Z builds of GitHub Actions runner, and stable qemu-user has problems with .NET apps, so the builder runs the x86_64 runner version with qemu-user built from the master branch.</p>
<h2><a class="anchor" id="autotoc_md712"></a>
Configuring the builder.</h2>
<h3><a class="anchor" id="autotoc_md713"></a>
Install prerequisites.</h3>
<div class="fragment"><div class="line">$ sudo dnf install docker</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md714"></a>
Add services.</h3>
<div class="fragment"><div class="line">$ sudo cp self-hosted-builder/*.service /etc/systemd/system/</div>
<div class="line">$ sudo systemctl daemon-reload</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md715"></a>
Create a config file.</h3>
<div class="fragment"><div class="line">$ sudo tee /etc/actions-runner</div>
<div class="line">repo=&lt;owner&gt;/&lt;name&gt;</div>
<div class="line">access_token=&lt;ghp_***&gt;</div>
</div><!-- fragment --><p>Access token should have the repo scope, consult <a href="https://docs.github.com/en/rest/reference/actions#create-a-registration-token-for-a-repository">https://docs.github.com/en/rest/reference/actions#create-a-registration-token-for-a-repository</a> for details.</p>
<h3><a class="anchor" id="autotoc_md716"></a>
Autostart the x86_64 emulation support.</h3>
<div class="fragment"><div class="line">$ sudo systemctl enable --now qemu-user-static</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md717"></a>
Autostart the runner.</h3>
<div class="fragment"><div class="line">$ sudo systemctl enable --now actions-runner</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md718"></a>
Rebuilding the image</h2>
<p>In order to update the <code>iiilinuxibmcom/actions-runner</code> image, e.g. to get the latest OS security fixes, use the following commands:</p>
<div class="fragment"><div class="line">$ sudo docker build \</div>
<div class="line">      --pull \</div>
<div class="line">      -f self-hosted-builder/actions-runner.Dockerfile \</div>
<div class="line">      -t iiilinuxibmcom/actions-runner</div>
<div class="line">$ sudo systemctl restart actions-runner</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md719"></a>
Removing persistent data</h2>
<p>The <code>actions-runner</code> service stores various temporary data, such as runner registration information, work directories and logs, in the <code>actions-runner</code> volume. In order to remove it and start from scratch, e.g. when switching the runner to a different repository, use the following commands:</p>
<div class="fragment"><div class="line">$ sudo systemctl stop actions-runner</div>
<div class="line">$ sudo docker rm -f actions-runner</div>
<div class="line">$ sudo docker volume rm actions-runner</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
