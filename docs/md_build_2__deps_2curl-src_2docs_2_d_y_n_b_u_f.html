<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CrossGuard: dynbuf</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CrossGuard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">dynbuf</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md218"></a> This is the internal module for creating and handling "dynamic buffers". This means buffers that can be appended to, dynamically and grow to adapt.</p>
<p>There will always be a terminating zero put at the end of the dynamic buffer.</p>
<p>The <code>struct dynbuf</code> is used to hold data for each instance of a dynamic buffer. The members of that struct <b>MUST NOT</b> be accessed or modified without using the dedicated dynbuf API.</p>
<h1><a class="anchor" id="autotoc_md219"></a>
<code>Curl_dyn_init</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Curl_dyn_init(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keywordtype">size_t</span> toobig);</div>
<div class="ttc" id="astructdynbuf_html"><div class="ttname"><a href="structdynbuf.html">dynbuf</a></div><div class="ttdef"><b>Definition</b> dynbuf.h:47</div></div>
</div><!-- fragment --><p>This initializes a struct to use for dynbuf and it cannot fail. The <code>toobig</code> value <b>must</b> be set to the maximum size we allow this buffer instance to grow to. The functions below will return <code>CURLE_OUT_OF_MEMORY</code> when hitting this limit.</p>
<h1><a class="anchor" id="autotoc_md220"></a>
<code>Curl_dyn_free</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Curl_dyn_free(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s);</div>
</div><!-- fragment --><p>Free the associated memory and clean up. After a free, the <code>dynbuf</code> struct can be reused to start appending new data to.</p>
<h1><a class="anchor" id="autotoc_md221"></a>
<code>Curl_dyn_addn</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_addn(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keyword">const</span> <span class="keywordtype">void</span> *mem, <span class="keywordtype">size_t</span> len);</div>
</div><!-- fragment --><p>Append arbitrary data of a given length to the end of the buffer.</p>
<p>If this function fails it calls <code>Curl_dyn_free</code> on <code>dynbuf</code>.</p>
<h1><a class="anchor" id="autotoc_md222"></a>
<code>Curl_dyn_add</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_add(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *str);</div>
</div><!-- fragment --><p>Append a C string to the end of the buffer.</p>
<p>If this function fails it calls <code>Curl_dyn_free</code> on <code>dynbuf</code>.</p>
<h1><a class="anchor" id="autotoc_md223"></a>
<code>Curl_dyn_addf</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_addf(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...);</div>
</div><!-- fragment --><p>Append a <code>printf()</code>-style string to the end of the buffer.</p>
<p>If this function fails it calls <code>Curl_dyn_free</code> on <code>dynbuf</code>.</p>
<h1><a class="anchor" id="autotoc_md224"></a>
<code>Curl_dyn_vaddf</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_vaddf(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap);</div>
</div><!-- fragment --><p>Append a <code>vprintf()</code>-style string to the end of the buffer.</p>
<p>If this function fails it calls <code>Curl_dyn_free</code> on <code>dynbuf</code>.</p>
<h1><a class="anchor" id="autotoc_md225"></a>
<code>Curl_dyn_reset</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Curl_dyn_reset(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s);</div>
</div><!-- fragment --><p>Reset the buffer length, but leave the allocation.</p>
<h1><a class="anchor" id="autotoc_md226"></a>
<code>Curl_dyn_tail</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_tail(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keywordtype">size_t</span> length);</div>
</div><!-- fragment --><p>Keep <code>length</code> bytes of the buffer tail (the last <code>length</code> bytes of the buffer). The rest of the buffer is dropped. The specified <code>length</code> must not be larger than the buffer length. To instead keep the leading part, see <code>Curl_dyn_setlen()</code>.</p>
<h1><a class="anchor" id="autotoc_md227"></a>
<code>Curl_dyn_ptr</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *Curl_dyn_ptr(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s);</div>
</div><!-- fragment --><p>Returns a <code>char *</code> to the buffer if it has a length, otherwise may return NULL. Since the buffer may be reallocated, this pointer should not be trusted or used anymore after the next buffer manipulation call.</p>
<h1><a class="anchor" id="autotoc_md228"></a>
<code>Curl_dyn_uptr</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Curl_dyn_uptr(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s);</div>
</div><!-- fragment --><p>Returns an <code>unsigned char *</code> to the buffer if it has a length, otherwise may return NULL. Since the buffer may be reallocated, this pointer should not be trusted or used anymore after the next buffer manipulation call.</p>
<h1><a class="anchor" id="autotoc_md229"></a>
<code>Curl_dyn_len</code></h1>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> Curl_dyn_len(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s);</div>
</div><!-- fragment --><p>Returns the length of the buffer in bytes. Does not include the terminating zero byte.</p>
<h1><a class="anchor" id="autotoc_md230"></a>
<code>Curl_dyn_setlen</code></h1>
<div class="fragment"><div class="line">CURLcode Curl_dyn_setlen(<span class="keyword">struct</span> <a class="code hl_struct" href="structdynbuf.html">dynbuf</a> *s, <span class="keywordtype">size_t</span> len);</div>
</div><!-- fragment --><p>Sets the new shorter length of the buffer in number of bytes. Keeps the leftmost set number of bytes, discards the rest. To instead keep the tail part of the buffer, see <code>Curl_dyn_tail()</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
