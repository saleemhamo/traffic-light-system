<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CrossGuard: URL syntax and their use in curl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CrossGuard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">URL syntax and their use in curl</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md528"></a> </p>
<h1><a class="anchor" id="autotoc_md529"></a>
Specifications</h1>
<p>The official "URL syntax" is primarily defined in these two different specifications:</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a> (although URL is called "URI" in there)</li>
<li><a href="https://url.spec.whatwg.org/">The WHATWG URL Specification</a></li>
</ul>
<p>RFC 3986 is the earlier one, and curl has always tried to adhere to that one (since it shipped in January 2005).</p>
<p>The WHATWG URL spec was written later, is incompatible with the RFC 3986 and changes over time.</p>
<h1><a class="anchor" id="autotoc_md530"></a>
Variations</h1>
<p>URL parsers as implemented in browsers, libraries and tools usually opt to support one of the mentioned specifications. Bugs, differences in interpretations and the moving nature of the WHATWG spec does however make it unlikely that multiple parsers treat URLs the same way.</p>
<h1><a class="anchor" id="autotoc_md531"></a>
Security</h1>
<p>Due to the inherent differences between URL parser implementations, it is considered a security risk to mix different implementations and assume the same behavior!</p>
<p>For example, if you use one parser to check if a URL uses a good host name or the correct auth field, and then pass on that same URL to a <em>second</em> parser, there will always be a risk it treats the same URL differently. There is no right and wrong in URL land, only differences of opinions.</p>
<p>libcurl offers a separate API to its URL parser for this reason, among others.</p>
<p>Applications may at times find it convenient to allow users to specify URLs for various purposes and that string would then end up fed to curl. Getting a URL from an external untrusted party and using it with curl brings several security concerns:</p>
<ol type="1">
<li>If you have an application that runs as or in a server application, getting an unfiltered URL can trick your application to access a local resource instead of a remote resource. Protecting yourself against localhost accesses is hard when accepting user provided URLs.</li>
<li>Such custom URLs can access other ports than you planned as port numbers are part of the regular URL format. The combination of a local host and a custom port number can allow external users to play tricks with your local services.</li>
<li>Such a URL might use other schemes than you thought of or planned for.</li>
</ol>
<h1><a class="anchor" id="autotoc_md532"></a>
"RFC 3986 plus"</h1>
<p>curl recognizes a URL syntax that we call "RFC 3986 plus". It is grounded on the well established RFC 3986 to make sure previously written command lines and curl using scripts will remain working.</p>
<p>curl's URL parser allows a few deviations from the spec in order to inter-operate better with URLs that appear in the wild.</p>
<h2><a class="anchor" id="autotoc_md533"></a>
spaces</h2>
<p>A URL provided to curl cannot contain spaces. They need to be provided URL encoded to be accepted in a URL by curl.</p>
<p>An exception to this rule: <code>Location:</code> response headers that indicate to a client where a resource has been redirected to, sometimes contain spaces. This is a violation of RFC 3986 but is fine in the WHATWG spec. curl handles these by re-encoding them to <code>%20</code>.</p>
<h2><a class="anchor" id="autotoc_md534"></a>
non-ASCII</h2>
<p>Byte values in a provided URL that are outside of the printable ASCII range are percent-encoded by curl.</p>
<h2><a class="anchor" id="autotoc_md535"></a>
multiple slashes</h2>
<p>An absolute URL always starts with a "scheme" followed by a colon. For all the schemes curl supports, the colon must be followed by two slashes according to RFC 3986 but not according to the WHATWG spec - which allows one to infinity amount.</p>
<p>curl allows one, two or three slashes after the colon to still be considered a valid URL.</p>
<h2><a class="anchor" id="autotoc_md536"></a>
"scheme-less"</h2>
<p>curl supports "URLs" that do not start with a scheme. This is not supported by any of the specifications. This is a shortcut to entering URLs that was supported by browsers early on and has been mimicked by curl.</p>
<p>Based on what the host name starts with, curl will "guess" what protocol to use:</p>
<ul>
<li><code>ftp.</code> means <a class="el" href="struct_f_t_p.html">FTP</a></li>
<li><code>dict.</code> means DICT</li>
<li><code>ldap.</code> means LDAP</li>
<li><code>imap.</code> means <a class="el" href="struct_i_m_a_p.html">IMAP</a></li>
<li><code>smtp.</code> means <a class="el" href="struct_s_m_t_p.html">SMTP</a></li>
<li><code>pop3.</code> means <a class="el" href="struct_p_o_p3.html">POP3</a></li>
<li>all other means <a class="el" href="struct_h_t_t_p.html">HTTP</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md537"></a>
globbing letters</h2>
<p>The curl command line tool supports "globbing" of URLs. It means that you can create ranges and lists using <code>[N-M]</code> and <code>{one,two,three}</code> sequences. The letters used for this (<code>[]{}</code>) are reserved in RFC 3986 and can therefore not legitimately be part of such a URL.</p>
<p>They are however not reserved or special in the WHATWG specification, so globbing can mess up such URLs. Globbing can be turned off for such occasions (using <code>--globoff</code>).</p>
<h1><a class="anchor" id="autotoc_md538"></a>
URL syntax details</h1>
<p>A URL may consist of the following components - many of them are optional: </p><pre class="fragment">[scheme][divider][userinfo][hostname][port number][path][query][fragment]
</pre><p> Each component is separated from the following component with a divider character or string.</p>
<p>For example, this could look like: </p><pre class="fragment">http://user:password@www.example.com:80/index.html?foo=bar#top
</pre> <h2><a class="anchor" id="autotoc_md539"></a>
Scheme</h2>
<p>The scheme specifies the protocol to use. A curl build can support a few or many different schemes. You can limit what schemes curl should accept.</p>
<p>curl supports the following schemes on URLs specified to transfer. They are matched case insensitively:</p>
<p><code>dict</code>, <code>file</code>, <code>ftp</code>, <code>ftps</code>, <code>gopher</code>, <code>gophers</code>, <code>http</code>, <code>https</code>, <code>imap</code>, <code>imaps</code>, <code>ldap</code>, <code>ldaps</code>, <code>mqtt</code>, <code>pop3</code>, <code>pop3s</code>, <code>rtmp</code>, <code>rtmpe</code>, <code>rtmps</code>, <code>rtmpt</code>, <code>rtmpte</code>, <code>rtmpts</code>, <code>rtsp</code>, <code>smb</code>, <code>smbs</code>, <code>smtp</code>, <code>smtps</code>, <code>telnet</code>, <code>tftp</code></p>
<p>When the URL is specified to identify a proxy, curl recognizes the following schemes:</p>
<p><code>http</code>, <code>https</code>, <code>socks4</code>, <code>socks4a</code>, <code>socks5</code>, <code>socks5h</code>, <code>socks</code></p>
<h2><a class="anchor" id="autotoc_md540"></a>
Userinfo</h2>
<p>The userinfo field can be used to set user name and password for authentication purposes in this transfer. The use of this field is discouraged since it often means passing around the password in plain text and is thus a security risk.</p>
<p>URLs for <a class="el" href="struct_i_m_a_p.html">IMAP</a>, <a class="el" href="struct_p_o_p3.html">POP3</a> and <a class="el" href="struct_s_m_t_p.html">SMTP</a> also support <em>login options</em> as part of the userinfo field. They are provided as a semicolon after the password and then the options.</p>
<h2><a class="anchor" id="autotoc_md541"></a>
Hostname</h2>
<p>The hostname part of the URL contains the address of the server that you want to connect to. This can be the fully qualified domain name of the server, the local network name of the machine on your network or the IP address of the server or machine represented by either an IPv4 or IPv6 address (within brackets). For example: </p><pre class="fragment">http://www.example.com/

http://hostname/

http://192.168.0.1/

http://[2001:1890:1112:1::20]/
</pre> <h3><a class="anchor" id="autotoc_md542"></a>
"localhost"</h3>
<p>Starting in curl 7.77.0, curl uses loopback IP addresses for the name <code>localhost</code>: <code>127.0.0.1</code> and <code>::1</code>. It does not resolve the name using the resolver functions.</p>
<p>This is done to make sure the host accessed is truly the localhost - the local machine.</p>
<h3><a class="anchor" id="autotoc_md543"></a>
IDNA</h3>
<p>If curl was built with International Domain Name (IDN) support, it can also handle host names using non-ASCII characters.</p>
<p>When built with libidn2, curl uses the IDNA 2008 standard. This is equivalent to the WHATWG URL spec, but differs from certain browsers that use IDNA 2003 Transitional Processing. The two standards have a huge overlap but differ slightly, perhaps most famously in how they deal with the German "double s" (<code>ÃŸ</code>).</p>
<p>When winidn is used, curl uses IDNA 2003 Transitional Processing, like the rest of Windows.</p>
<h2><a class="anchor" id="autotoc_md544"></a>
Port number</h2>
<p>If there is a colon after the hostname, that should be followed by the port number to use. 1 - 65535. curl also supports a blank port number field - but only if the URL starts with a scheme.</p>
<p>If the port number is not specified in the URL, curl will used a default port based on the provide scheme:</p>
<p>DICT 2628, <a class="el" href="struct_f_t_p.html">FTP</a> 21, FTPS 990, GOPHER 70, GOPHERS 70, <a class="el" href="struct_h_t_t_p.html">HTTP</a> 80, HTTPS 443, <a class="el" href="struct_i_m_a_p.html">IMAP</a> 132, IMAPS 993, LDAP 369, LDAPS 636, <a class="el" href="struct_m_q_t_t.html">MQTT</a> 1883, <a class="el" href="struct_p_o_p3.html">POP3</a> 110, POP3S 995, RTMP 1935, RTMPS 443, RTMPT 80, <a class="el" href="struct_r_t_s_p.html">RTSP</a> 554, SCP 22, SFTP 22, SMB 445, SMBS 445, <a class="el" href="struct_s_m_t_p.html">SMTP</a> 25, SMTPS 465, <a class="el" href="struct_t_e_l_n_e_t.html">TELNET</a> 23, TFTP 69</p>
<h1><a class="anchor" id="autotoc_md545"></a>
Scheme specific behaviors</h1>
<h2><a class="anchor" id="autotoc_md546"></a>
FTP</h2>
<p>The path part of an <a class="el" href="struct_f_t_p.html">FTP</a> request specifies the file to retrieve and from which directory. If the file part is omitted then libcurl downloads the directory listing for the directory specified. If the directory is omitted then the directory listing for the root / home directory will be returned.</p>
<p><a class="el" href="struct_f_t_p.html">FTP</a> servers typically put the user in its "home directory" after login, which then differs between users. To explicitly specify the root directory of an <a class="el" href="struct_f_t_p.html">FTP</a> server, start the path with double slash <code>//</code> or <code>/%2f</code> (2F is the hexadecimal value of the ascii code for the slash).</p>
<h2><a class="anchor" id="autotoc_md547"></a>
FILE</h2>
<p>When a <code>FILE://</code> URL is accessed on Windows systems, it can be crafted in a way so that Windows attempts to connect to a (remote) machine when curl wants to read or write such a path.</p>
<p>curl only allows the hostname part of a FILE URL to be one out of these three alternatives: <code>localhost</code>, <code>127.0.0.1</code> or blank ("", zero characters). Anything else will make curl fail to parse the URL.</p>
<h3><a class="anchor" id="autotoc_md548"></a>
Windows-specific FILE details</h3>
<p>curl accepts that the FILE URL's path starts with a "drive letter". That is a single letter <code>a</code> to <code>z</code> followed by a colon or a pipe character (<code>|</code>).</p>
<p>The Windows operating system itself will convert some file accesses to perform network accesses over SMB/CIFS, through several different file path patterns. This way, a <code><a href="file://">file://</a></code> URL passed to curl <em>might</em> be converted into a network access inadvertently and unknowingly to curl. This is a Windows feature curl cannot control or disable.</p>
<h2><a class="anchor" id="autotoc_md549"></a>
IMAP</h2>
<p>The path part of an <a class="el" href="struct_i_m_a_p.html">IMAP</a> request not only specifies the mailbox to list or select, but can also be used to check the <code>UIDVALIDITY</code> of the mailbox, to specify the <code>UID</code>, <code>SECTION</code> and <code>PARTIAL</code> octets of the message to fetch and to specify what messages to search for.</p>
<p>A top level folder list: </p><pre class="fragment">imap://user:password@mail.example.com
</pre><p> A folder list on the user's inbox: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX
</pre><p> Select the user's inbox and fetch message with <code>uid = 1</code>: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX/;UID=1
</pre><p> Select the user's inbox and fetch the first message in the mail box: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX/;MAILINDEX=1
</pre><p> Select the user's inbox, check the <code>UIDVALIDITY</code> of the mailbox is 50 and fetch message 2 if it is: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX;UIDVALIDITY=50/;UID=2
</pre><p> Select the user's inbox and fetch the text portion of message 3: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX/;UID=3/;SECTION=TEXT
</pre><p> Select the user's inbox and fetch the first 1024 octets of message 4: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX/;UID=4/;PARTIAL=0.1024
</pre><p> Select the user's inbox and check for NEW messages: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX?NEW
</pre><p> Select the user's inbox and search for messages containing "shadows" in the subject line: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX?SUBJECT%20shadows
</pre><p> Searching via the query part of the URL <code>?</code> is a search request for the results to be returned as message sequence numbers (<code>MAILINDEX</code>). It is possible to make a search request for results to be returned as unique ID numbers (<code>UID</code>) by using a custom curl request via <code>-X</code>. <code>UID</code> numbers are unique per session (and multiple sessions when <code>UIDVALIDITY</code> is the same). For example, if you are searching for <code>"foo bar"</code> in header+body (<code>TEXT</code>) and you want the matching <code>MAILINDEX</code> numbers returned then you could search via URL: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX?TEXT%20%22foo%20bar%22
</pre><p> If you want matching <code>UID</code> numbers you have to use a custom request: </p><pre class="fragment">imap://user:password@mail.example.com/INBOX -X "UID SEARCH TEXT \"foo bar\""
</pre><p> For more information about <a class="el" href="struct_i_m_a_p.html">IMAP</a> commands please see RFC 9051. For more information about the individual components of an <a class="el" href="struct_i_m_a_p.html">IMAP</a> URL please see RFC 5092.</p>
<ul>
<li>Note old curl versions would <code>FETCH</code> by message sequence number when <code>UID</code> was specified in the URL. That was a bug fixed in 7.62.0, which added <code>MAILINDEX</code> to <code>FETCH</code> by mail sequence number.</li>
</ul>
<h2><a class="anchor" id="autotoc_md550"></a>
LDAP</h2>
<p>The path part of a LDAP request can be used to specify the: Distinguished Name, Attributes, Scope, Filter and Extension for a LDAP search. Each field is separated by a question mark and when that field is not required an empty string with the question mark separator should be included.</p>
<p>Search for the <code>DN</code> as <code>My Organization</code>: </p><pre class="fragment">ldap://ldap.example.com/o=My%20Organization
</pre><p> the same search but will only return <code>postalAddress</code> attributes: </p><pre class="fragment">ldap://ldap.example.com/o=My%20Organization?postalAddress
</pre><p> Search for an empty <code>DN</code> and request information about the <code>rootDomainNamingContext</code> attribute for an Active Directory server: </p><pre class="fragment">ldap://ldap.example.com/?rootDomainNamingContext
</pre><p> For more information about the individual components of a LDAP URL please see <a href="https://datatracker.ietf.org/doc/html/rfc4516">RFC 4516</a>.</p>
<h2><a class="anchor" id="autotoc_md551"></a>
POP3</h2>
<p>The path part of a <a class="el" href="struct_p_o_p3.html">POP3</a> request specifies the message ID to retrieve. If the ID is not specified then a list of waiting messages is returned instead.</p>
<h2><a class="anchor" id="autotoc_md552"></a>
SCP</h2>
<p>The path part of an SCP URL specifies the path and file to retrieve or upload. The file is taken as an absolute path from the root directory on the server.</p>
<p>To specify a path relative to the user's home directory on the server, prepend <code>~/</code> to the path portion.</p>
<h2><a class="anchor" id="autotoc_md553"></a>
SFTP</h2>
<p>The path part of an SFTP URL specifies the file to retrieve or upload. If the path ends with a slash (<code>/</code>) then a directory listing is returned instead of a file. If the path is omitted entirely then the directory listing for the root / home directory will be returned.</p>
<h2><a class="anchor" id="autotoc_md554"></a>
SMB</h2>
<p>The path part of a SMB request specifies the file to retrieve and from what share and directory or the share to upload to and as such, may not be omitted. If the user name is embedded in the URL then it must contain the domain name and as such, the backslash must be URL encoded as %2f.</p>
<p>When uploading to SMB, the size of the file needs to be known ahead of time, meaning that you can upload a file passed to curl over a pipe like stdin.</p>
<p>curl supports SMB version 1 (only)</p>
<h2><a class="anchor" id="autotoc_md555"></a>
SMTP</h2>
<p>The path part of a <a class="el" href="struct_s_m_t_p.html">SMTP</a> request specifies the host name to present during communication with the mail server. If the path is omitted, then libcurl will attempt to resolve the local computer's host name. However, this may not return the fully qualified domain name that is required by some mail servers and specifying this path allows you to set an alternative name, such as your machine's fully qualified domain name, which you might have obtained from an external function such as gethostname or getaddrinfo.</p>
<p>The default smtp port is 25. Some servers use port 587 as an alternative.</p>
<h2><a class="anchor" id="autotoc_md556"></a>
RTMP</h2>
<p>There is no official URL spec for RTMP so libcurl uses the URL syntax supported by the underlying librtmp library. It has a syntax where it wants a traditional URL, followed by a space and a series of space-separated <code>name=value</code> pairs.</p>
<p>While space is not typically a "legal" letter, libcurl accepts them. When a user wants to pass in a <code>#</code> (hash) character it will be treated as a fragment and get cut off by libcurl if provided literally. You will instead have to escape it by providing it as backslash and its ASCII value in hexadecimal: <code>\23</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
